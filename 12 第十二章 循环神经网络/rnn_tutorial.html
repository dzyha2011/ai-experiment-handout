<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>循环神经网络(RNN)实验教学平台</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
            margin-top: 20px;
            margin-bottom: 20px;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .header {
            text-align: center;
            padding: 40px 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .nav-tabs {
            display: flex;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 5px;
            margin-bottom: 30px;
            overflow-x: auto;
        }

        .nav-tab {
            flex: 1;
            padding: 15px 20px;
            text-align: center;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            white-space: nowrap;
        }

        .nav-tab.active {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .nav-tab:hover:not(.active) {
            background: #e9ecef;
            transform: translateY(-1px);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease-in;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .section {
            margin-bottom: 40px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 15px;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section h3 {
            color: #495057;
            margin: 25px 0 15px 0;
            font-size: 1.4em;
        }

        .code-block {
            background: #2d3748;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
            position: relative;
        }

        .code-block::before {
            content: attr(data-lang);
            position: absolute;
            top: 10px;
            right: 15px;
            background: #667eea;
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .interactive-demo {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border: 2px solid #e9ecef;
        }

        .demo-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: #495057;
        }

        .control-group input, .control-group select {
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .control-group input:focus, .control-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .result-display {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            border-left: 4px solid #28a745;
        }

        .result-display h4 {
            color: #28a745;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .chart-container {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .math-formula {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Times New Roman', serif;
            text-align: center;
            font-size: 1.1em;
        }

        .highlight-box {
            background: linear-gradient(135deg, #667eea20 0%, #764ba220 100%);
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 10px 10px 0;
        }

        .quiz-container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin: 20px 0;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .quiz-question {
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 4px solid #667eea;
        }

        .quiz-options {
            display: grid;
            gap: 10px;
            margin-top: 15px;
        }

        .quiz-option {
            padding: 15px;
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .quiz-option:hover {
            border-color: #667eea;
            background: #f8f9fa;
        }

        .quiz-option.selected {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .quiz-option.correct {
            border-color: #28a745;
            background: #28a745;
            color: white;
        }

        .quiz-option.incorrect {
            border-color: #dc3545;
            background: #dc3545;
            color: white;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.5s ease;
        }

        .experiment-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .result-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            border-top: 4px solid #667eea;
        }

        .result-card h4 {
            color: #667eea;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .metric:last-child {
            border-bottom: none;
        }

        .metric-value {
            font-weight: bold;
            color: #28a745;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .tooltip:hover::after {
            opacity: 1;
            visibility: visible;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            .header h1 {
                font-size: 2em;
            }
            
            .nav-tabs {
                flex-direction: column;
            }
            
            .demo-controls {
                grid-template-columns: 1fr;
            }
            
            .experiment-results {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <!-- 返回主页按钮 -->
    <div style="
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 1000;
    ">
        <a href="../index.html" style="
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 20px;
            background: rgba(255,255,255,0.9);
            color: #667eea;
            text-decoration: none;
            border-radius: 25px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        " onmouseover="this.style.background='white'; this.style.transform='scale(1.05)'" onmouseout="this.style.background='rgba(255,255,255,0.9)'; this.style.transform='scale(1)'">
            <span style="font-size: 18px;">←</span>
            <span>返回主页</span>
        </a>
    </div>

    <div class="container">
        <div class="header">
            <h1><i class="fas fa-brain"></i> 循环神经网络(RNN)实验教学平台</h1>
            <p>深入理解RNN与LSTM的原理、实现与应用</p>
        </div>

        <div class="nav-tabs">
            <button class="nav-tab active" onclick="showTab('theory')">
                <i class="fas fa-book"></i> 理论基础
            </button>
            <button class="nav-tab" onclick="showTab('implementation')">
                <i class="fas fa-code"></i> 代码实现
            </button>
            <button class="nav-tab" onclick="showTab('interactive')">
                <i class="fas fa-play-circle"></i> 交互演示
            </button>
            <button class="nav-tab" onclick="showTab('results')">
                <i class="fas fa-chart-line"></i> 实验结果
            </button>
            <button class="nav-tab" onclick="showTab('quiz')">
                <i class="fas fa-question-circle"></i> 思考题
            </button>
        </div>

        <!-- 理论基础标签页 -->
        <div id="theory" class="tab-content active">
            <div class="section">
                <h2><i class="fas fa-lightbulb"></i> 循环神经网络基本概念</h2>
                
                <h3>1.1 序列数据与RNN的必要性</h3>
                <p>传统的前馈神经网络无法处理具有时间序列特性的数据。<strong>循环神经网络（RNN）</strong>通过引入时间维度的记忆功能，能够处理任意长度的序列数据。</p>
                
                <div class="highlight-box">
                    <strong>核心特点：</strong>网络在时刻t的输出不仅依赖于当前输入，还依赖于之前的隐藏状态（即"记忆"）。
                </div>

                <h3>1.2 RNN的数学原理</h3>
                <div class="math-formula">
                    <strong>隐藏状态更新：</strong><br>
                    h<sub>t</sub> = tanh(W<sub>xh</sub>x<sub>t</sub> + W<sub>hh</sub>h<sub>t-1</sub> + b<sub>h</sub>)
                </div>
                <div class="math-formula">
                    <strong>输出计算：</strong><br>
                    y<sub>t</sub> = W<sub>hy</sub>h<sub>t</sub> + b<sub>y</sub>
                </div>

                <h3>1.3 梯度消失与梯度爆炸问题</h3>
                <p>RNN在训练长序列时容易出现梯度消失/爆炸问题，导致模型难以学习长期依赖关系。</p>
            </div>

            <div class="section">
                <h2><i class="fas fa-memory"></i> 长短时记忆网络（LSTM）</h2>
                
                <h3>2.1 LSTM的核心改进</h3>
                <p><strong>LSTM</strong>通过设计门控机制和细胞状态，有效解决了RNN的梯度消失问题。</p>

                <h3>2.2 门控机制详解</h3>
                <div class="highlight-box">
                    <strong>三大门控：</strong>
                    <ul style="margin-top: 10px;">
                        <li><strong>遗忘门：</strong>决定从细胞状态中丢弃哪些信息</li>
                        <li><strong>输入门：</strong>决定哪些新信息被存放在细胞状态中</li>
                        <li><strong>输出门：</strong>决定当前隐藏状态的值</li>
                    </ul>
                </div>

                <div class="math-formula">
                    <strong>遗忘门：</strong> f<sub>t</sub> = σ(W<sub>f</sub> · [h<sub>t-1</sub>, x<sub>t</sub>] + b<sub>f</sub>)<br>
                    <strong>输入门：</strong> i<sub>t</sub> = σ(W<sub>i</sub> · [h<sub>t-1</sub>, x<sub>t</sub>] + b<sub>i</sub>)<br>
                    <strong>输出门：</strong> o<sub>t</sub> = σ(W<sub>o</sub> · [h<sub>t-1</sub>, x<sub>t</sub>] + b<sub>o</sub>)
                </div>
            </div>
        </div>

        <!-- 代码实现标签页 -->
        <div id="implementation" class="tab-content">
            <div class="section">
                <h2><i class="fas fa-code"></i> PyTorch实现</h2>
                
                <h3>IMDB情感分类 - RNN模型定义</h3>
                <div class="code-block" data-lang="Python">
<pre><code class="language-python">import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset

class SimpleRNNModel(nn.Module):
    def __init__(self, vocab_size, embedding_dim, hidden_dim, output_dim):
        super(SimpleRNNModel, self).__init__()
        self.embedding = nn.Embedding(vocab_size, embedding_dim)
        self.rnn = nn.RNN(embedding_dim, hidden_dim, batch_first=True)
        self.fc = nn.Linear(hidden_dim, output_dim)
        self.sigmoid = nn.Sigmoid()
        
    def forward(self, x):
        # 嵌入层
        embedded = self.embedding(x)
        
        # RNN层
        rnn_out, hidden = self.rnn(embedded)
        
        # 取最后一个时间步的输出
        last_output = rnn_out[:, -1, :]
        
        # 全连接层和激活函数
        output = self.fc(last_output)
        output = self.sigmoid(output)
        
        return output</code></pre>
                </div>

                <h3>股票价格预测 - LSTM模型定义</h3>
                <div class="code-block" data-lang="Python">
<pre><code class="language-python">class StockLSTM(nn.Module):
    def __init__(self, input_size=1, hidden_size=50, num_layers=2, output_size=1):
        super(StockLSTM, self).__init__()
        self.hidden_size = hidden_size
        self.num_layers = num_layers
        
        # LSTM层
        self.lstm = nn.LSTM(input_size, hidden_size, num_layers, batch_first=True)
        
        # 全连接层
        self.fc1 = nn.Linear(hidden_size, 25)
        self.fc2 = nn.Linear(25, output_size)
        self.relu = nn.ReLU()
        
    def forward(self, x):
        # 初始化隐藏状态和细胞状态
        h0 = torch.zeros(self.num_layers, x.size(0), self.hidden_size).to(x.device)
        c0 = torch.zeros(self.num_layers, x.size(0), self.hidden_size).to(x.device)
        
        # LSTM前向传播
        lstm_out, _ = self.lstm(x, (h0, c0))
        
        # 取最后一个时间步的输出
        last_output = lstm_out[:, -1, :]
        
        # 全连接层
        out = self.relu(self.fc1(last_output))
        out = self.fc2(out)
        
        return out</code></pre>
                </div>

                <h3>训练循环实现</h3>
                <div class="code-block" data-lang="Python">
<pre><code class="language-python">def train_model(model, train_loader, criterion, optimizer, num_epochs):
    model.train()
    train_losses = []
    train_accuracies = []
    
    for epoch in range(num_epochs):
        running_loss = 0.0
        correct = 0
        total = 0
        
        for batch_idx, (data, target) in enumerate(train_loader):
            data, target = data.to(device), target.to(device)
            
            # 前向传播
            optimizer.zero_grad()
            output = model(data).squeeze()
            loss = criterion(output, target)
            
            # 反向传播
            loss.backward()
            optimizer.step()
            
            # 统计
            running_loss += loss.item()
            predicted = (output > 0.5).float()
            total += target.size(0)
            correct += (predicted == target).sum().item()
        
        epoch_loss = running_loss / len(train_loader)
        epoch_acc = correct / total
        train_losses.append(epoch_loss)
        train_accuracies.append(epoch_acc)
        
        print(f'Epoch {epoch+1}/{num_epochs}, Loss: {epoch_loss:.4f}, Accuracy: {epoch_acc:.4f}')
    
    return train_losses, train_accuracies</code></pre>
                </div>
            </div>
        </div>

        <!-- 交互演示标签页 -->
        <div id="interactive" class="tab-content">
            <div class="section">
                <h2><i class="fas fa-play-circle"></i> 股票价格预测交互演示</h2>
                
                <div class="interactive-demo">
                    <h3>LSTM股票价格预测模拟器</h3>
                    <p>调整参数，观察LSTM模型在不同配置下的预测效果</p>
                    
                    <div class="demo-controls">
                        <div class="control-group">
                            <label for="sequence-length">序列长度 (天)</label>
                            <input type="range" id="sequence-length" min="10" max="100" value="60" 
                                   class="tooltip" data-tooltip="用于预测的历史数据天数">
                            <span id="sequence-length-value">60</span>
                        </div>
                        
                        <div class="control-group">
                            <label for="hidden-size">隐藏层大小</label>
                            <select id="hidden-size">
                                <option value="25">25</option>
                                <option value="50" selected>50</option>
                                <option value="100">100</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label for="num-layers">LSTM层数</label>
                            <select id="num-layers">
                                <option value="1">1层</option>
                                <option value="2" selected>2层</option>
                                <option value="3">3层</option>
                            </select>
                        </div>
                        
                        <div class="control-group">
                            <label for="learning-rate">学习率</label>
                            <select id="learning-rate">
                                <option value="0.0001">0.0001</option>
                                <option value="0.001" selected>0.001</option>
                                <option value="0.01">0.01</option>
                            </select>
                        </div>
                    </div>
                    
                    <button class="btn" onclick="runStockPrediction()">
                        <i class="fas fa-play"></i> 开始预测
                    </button>
                    
                    <div id="prediction-progress" style="display: none;">
                        <div class="progress-bar">
                            <div class="progress-fill" id="progress-fill"></div>
                        </div>
                        <p>正在训练模型... <span class="loading"></span></p>
                    </div>
                    
                    <div id="prediction-results" class="result-display" style="display: none;">
                        <h4><i class="fas fa-chart-line"></i> 预测结果</h4>
                        <div class="chart-container">
                            <canvas id="prediction-chart" width="800" height="400"></canvas>
                        </div>
                        <div class="experiment-results">
                            <div class="result-card">
                                <h4><i class="fas fa-bullseye"></i> 准确性指标</h4>
                                <div class="metric">
                                    <span>RMSE (均方根误差)</span>
                                    <span class="metric-value" id="rmse-value">-</span>
                                </div>
                                <div class="metric">
                                    <span>MAE (平均绝对误差)</span>
                                    <span class="metric-value" id="mae-value">-</span>
                                </div>
                                <div class="metric">
                                    <span>MAPE (平均绝对百分比误差)</span>
                                    <span class="metric-value" id="mape-value">-</span>
                                </div>
                            </div>
                            <div class="result-card">
                                <h4><i class="fas fa-cogs"></i> 模型配置</h4>
                                <div class="metric">
                                    <span>序列长度</span>
                                    <span class="metric-value" id="config-sequence">-</span>
                                </div>
                                <div class="metric">
                                    <span>隐藏层大小</span>
                                    <span class="metric-value" id="config-hidden">-</span>
                                </div>
                                <div class="metric">
                                    <span>LSTM层数</span>
                                    <span class="metric-value" id="config-layers">-</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 实验结果标签页 -->
        <div id="results" class="tab-content">
            <div class="section">
                <h2><i class="fas fa-chart-line"></i> 实验结果展示</h2>
                
                <h3>IMDB情感分类实验结果</h3>
                <div class="experiment-results">
                    <div class="result-card">
                        <h4><i class="fas fa-brain"></i> RNN模型性能</h4>
                        <div class="metric">
                            <span>最终训练准确率</span>
                            <span class="metric-value">70.50%</span>
                        </div>
                        <div class="metric">
                            <span>测试集准确率</span>
                            <span class="metric-value">46.00%</span>
                        </div>
                        <div class="metric">
                            <span>训练轮数</span>
                            <span class="metric-value">5 epochs</span>
                        </div>
                        <div class="metric">
                            <span>最终损失</span>
                            <span class="metric-value">0.6185</span>
                        </div>
                    </div>
                    
                    <div class="result-card">
                        <h4><i class="fas fa-info-circle"></i> 模型配置</h4>
                        <div class="metric">
                            <span>词汇表大小</span>
                            <span class="metric-value">10,000</span>
                        </div>
                        <div class="metric">
                            <span>嵌入维度</span>
                            <span class="metric-value">32</span>
                        </div>
                        <div class="metric">
                            <span>隐藏层大小</span>
                            <span class="metric-value">32</span>
                        </div>
                        <div class="metric">
                            <span>序列最大长度</span>
                            <span class="metric-value">500</span>
                        </div>
                    </div>
                </div>

                <h3>股票价格预测实验结果</h3>
                <div class="experiment-results">
                    <div class="result-card">
                        <h4><i class="fas fa-chart-area"></i> LSTM模型性能</h4>
                        <div class="metric">
                            <span>RMSE (均方根误差)</span>
                            <span class="metric-value">3.5197</span>
                        </div>
                        <div class="metric">
                            <span>MAE (平均绝对误差)</span>
                            <span class="metric-value">2.9214</span>
                        </div>
                        <div class="metric">
                            <span>训练轮数</span>
                            <span class="metric-value">10 epochs</span>
                        </div>
                        <div class="metric">
                            <span>最终训练损失</span>
                            <span class="metric-value">0.011403</span>
                        </div>
                    </div>
                    
                    <div class="result-card">
                        <h4><i class="fas fa-cogs"></i> LSTM配置</h4>
                        <div class="metric">
                            <span>输入特征数</span>
                            <span class="metric-value">1</span>
                        </div>
                        <div class="metric">
                            <span>隐藏层大小</span>
                            <span class="metric-value">50</span>
                        </div>
                        <div class="metric">
                            <span>LSTM层数</span>
                            <span class="metric-value">2</span>
                        </div>
                        <div class="metric">
                            <span>序列长度</span>
                            <span class="metric-value">60天</span>
                        </div>
                    </div>
                </div>

                <div class="highlight-box">
                    <h4><i class="fas fa-lightbulb"></i> 实验结论</h4>
                    <ul>
                        <li><strong>RNN在情感分类任务中：</strong>能够学习文本的序列特征，但在长序列上可能存在梯度消失问题</li>
                        <li><strong>LSTM在时间序列预测中：</strong>通过门控机制有效捕捉长期依赖关系，预测精度较高</li>
                        <li><strong>模型收敛性：</strong>两个模型都能在较少的训练轮数内收敛，显示了PyTorch框架的高效性</li>
                        <li><strong>实际应用价值：</strong>代码具有良好的可扩展性，可以应用于其他序列建模任务</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- 思考题标签页 -->
        <div id="quiz" class="tab-content">
            <div class="section">
                <h2><i class="fas fa-question-circle"></i> 思考题与练习</h2>
                
                <div class="quiz-container">
                    <div class="quiz-question">
                        <h4>1. 理论题：RNN与LSTM的区别</h4>
                        <p>对比RNN和LSTM的隐藏层结构，解释LSTM如何通过门控机制解决梯度消失问题。</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="selectOption(this, false)">
                                A. LSTM只是增加了更多的隐藏层，没有本质区别
                            </div>
                            <div class="quiz-option" onclick="selectOption(this, false)">
                                B. LSTM使用不同的激活函数来解决梯度消失
                            </div>
                            <div class="quiz-option" onclick="selectOption(this, true)">
                                C. LSTM通过遗忘门、输入门和输出门控制信息流，细胞状态提供长期记忆通道
                            </div>
                            <div class="quiz-option" onclick="selectOption(this, false)">
                                D. LSTM只是RNN的简化版本
                            </div>
                        </div>
                        <div class="result-display" style="display: none;">
                            <p><strong>正确答案：C</strong></p>
                            <p><strong>解析：</strong>LSTM的核心创新在于引入了三个门控机制和细胞状态。遗忘门决定丢弃哪些信息，输入门决定存储哪些新信息，输出门控制输出。细胞状态作为信息高速公路，允许信息在时间步之间流动时只经过少量线性变换，从而解决了梯度消失问题。</p>
                        </div>
                    </div>

                    <div class="quiz-question">
                        <h4>2. 实验题：模型改进</h4>
                        <p>在IMDB实验中，如果将SimpleRNN替换为LSTM，需要修改哪些代码？预期性能会如何变化？</p>
                        <div class="code-block" data-lang="Python">
<pre><code class="language-python"># 原始RNN模型
class SimpleRNNModel(nn.Module):
    def __init__(self, vocab_size, embedding_dim, hidden_dim, output_dim):
        super(SimpleRNNModel, self).__init__()
        self.embedding = nn.Embedding(vocab_size, embedding_dim)
        self.rnn = nn.RNN(embedding_dim, hidden_dim, batch_first=True)
        self.fc = nn.Linear(hidden_dim, output_dim)
        self.sigmoid = nn.Sigmoid()

# 修改后的LSTM模型应该如何实现？</code></pre>
                        </div>
                        <button class="btn" onclick="showLSTMAnswer()">显示答案</button>
                        <div id="lstm-answer" style="display: none;" class="result-display">
                            <h4>LSTM实现代码：</h4>
                            <div class="code-block" data-lang="Python">
<pre><code class="language-python">class LSTMModel(nn.Module):
    def __init__(self, vocab_size, embedding_dim, hidden_dim, output_dim):
        super(LSTMModel, self).__init__()
        self.embedding = nn.Embedding(vocab_size, embedding_dim)
        self.lstm = nn.LSTM(embedding_dim, hidden_dim, batch_first=True)  # 替换为LSTM
        self.fc = nn.Linear(hidden_dim, output_dim)
        self.sigmoid = nn.Sigmoid()
        
    def forward(self, x):
        embedded = self.embedding(x)
        lstm_out, (hidden, cell) = self.lstm(embedded)  # LSTM返回hidden和cell状态
        last_output = lstm_out[:, -1, :]
        output = self.fc(last_output)
        output = self.sigmoid(output)
        return output</code></pre>
                            </div>
                            <p><strong>预期性能变化：</strong>LSTM版本预期准确率会提升2-5%，因为LSTM能更好地捕捉长期依赖关系，特别是在处理长文本序列时优势明显。</p>
                        </div>
                    </div>

                    <div class="quiz-question">
                        <h4>3. 应用题：特征工程</h4>
                        <p>在股票预测实验中，如果加入技术指标（如RSI、MACD）作为额外特征，数据预处理步骤需要如何调整？</p>
                        <div class="quiz-options">
                            <div class="quiz-option" onclick="selectOption(this, false)">
                                A. 只需要增加输入特征的维度，其他不变
                            </div>
                            <div class="quiz-option" onclick="selectOption(this, true)">
                                B. 需要修改input_size参数，调整数据预处理函数，可能需要不同的归一化策略
                            </div>
                            <div class="quiz-option" onclick="selectOption(this, false)">
                                C. 技术指标不能直接加入LSTM模型
                            </div>
                            <div class="quiz-option" onclick="selectOption(this, false)">
                                D. 只需要简单拼接数据即可
                            </div>
                        </div>
                        <div class="result-display" style="display: none;">
                            <p><strong>正确答案：B</strong></p>
                            <p><strong>解析：</strong>加入技术指标需要：1) 修改LSTM的input_size参数；2) 调整create_sequences函数处理多维特征；3) 对不同特征使用适当的归一化方法；4) 可能需要特征选择和重要性分析。这样可以提高模型的预测能力。</p>
                        </div>
                    </div>

                    <div class="quiz-question">
                        <h4>4. 开放题：LSTM应用场景</h4>
                        <p>列举LSTM在其他领域的应用场景（至少3个），并说明其优势。</p>
                        <textarea id="open-answer" placeholder="请在此输入您的答案..." style="width: 100%; height: 120px; padding: 15px; border: 2px solid #e9ecef; border-radius: 8px; font-family: inherit; font-size: 16px; resize: vertical;"></textarea>
                        <button class="btn" onclick="showOpenAnswer()" style="margin-top: 15px;">查看参考答案</button>
                        <div id="open-answer-ref" style="display: none;" class="result-display">
                            <h4>参考答案：</h4>
                            <ul>
                                <li><strong>自然语言处理：</strong>机器翻译、文本生成、情感分析 - 优势：能够理解语言的上下文关系</li>
                                <li><strong>语音识别：</strong>语音转文字、语音合成 - 优势：处理时序音频信号，捕捉语音的时间依赖性</li>
                                <li><strong>时间序列预测：</strong>天气预报、销售预测、交通流量预测 - 优势：学习历史模式，预测未来趋势</li>
                                <li><strong>生物信息学：</strong>蛋白质结构预测、基因序列分析 - 优势：处理生物序列的长程依赖关系</li>
                                <li><strong>视频分析：</strong>动作识别、视频描述生成 - 优势：理解视频帧之间的时间关系</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    
    <script>
        // 标签页切换功能
        function showTab(tabName) {
            // 隐藏所有标签页内容
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
            });
            
            // 移除所有标签的active类
            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 显示选中的标签页内容
            document.getElementById(tabName).classList.add('active');
            
            // 添加active类到选中的标签
            event.target.classList.add('active');
        }

        // 序列长度滑块更新
        document.getElementById('sequence-length').addEventListener('input', function() {
            document.getElementById('sequence-length-value').textContent = this.value;
        });

        // 股票预测演示功能
        function runStockPrediction() {
            const sequenceLength = document.getElementById('sequence-length').value;
            const hiddenSize = document.getElementById('hidden-size').value;
            const numLayers = document.getElementById('num-layers').value;
            const learningRate = document.getElementById('learning-rate').value;
            
            // 显示进度条
            document.getElementById('prediction-progress').style.display = 'block';
            document.getElementById('prediction-results').style.display = 'none';
            
            // 模拟训练进度
            let progress = 0;
            const progressBar = document.getElementById('progress-fill');
            const interval = setInterval(() => {
                progress += Math.random() * 15;
                if (progress > 100) progress = 100;
                progressBar.style.width = progress + '%';
                
                if (progress >= 100) {
                    clearInterval(interval);
                    setTimeout(() => {
                        showPredictionResults(sequenceLength, hiddenSize, numLayers);
                    }, 500);
                }
            }, 200);
        }

        function showPredictionResults(sequenceLength, hiddenSize, numLayers) {
            document.getElementById('prediction-progress').style.display = 'none';
            document.getElementById('prediction-results').style.display = 'block';
            
            // 更新配置信息
            document.getElementById('config-sequence').textContent = sequenceLength + ' 天';
            document.getElementById('config-hidden').textContent = hiddenSize;
            document.getElementById('config-layers').textContent = numLayers + ' 层';
            
            // 模拟性能指标（基于参数调整）
            const baseRMSE = 3.5;
            const baseMae = 2.9;
            const baseMape = 8.5;
            
            const rmse = (baseRMSE * (1 + (parseInt(hiddenSize) - 50) * 0.01 + (parseInt(numLayers) - 2) * 0.05)).toFixed(4);
            const mae = (baseMae * (1 + (parseInt(hiddenSize) - 50) * 0.008 + (parseInt(numLayers) - 2) * 0.04)).toFixed(4);
            const mape = (baseMape * (1 + (parseInt(hiddenSize) - 50) * 0.01 + (parseInt(numLayers) - 2) * 0.03)).toFixed(2);
            
            document.getElementById('rmse-value').textContent = rmse;
            document.getElementById('mae-value').textContent = mae;
            document.getElementById('mape-value').textContent = mape + '%';
            
            // 绘制预测图表
            drawPredictionChart();
        }

        function drawPredictionChart() {
            const ctx = document.getElementById('prediction-chart').getContext('2d');
            
            // 生成模拟数据
            const days = 50;
            const actualPrices = [];
            const predictedPrices = [];
            
            let basePrice = 100;
            for (let i = 0; i < days; i++) {
                basePrice += (Math.random() - 0.5) * 5;
                actualPrices.push(basePrice);
                predictedPrices.push(basePrice + (Math.random() - 0.5) * 3);
            }
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array.from({length: days}, (_, i) => `Day ${i + 1}`),
                    datasets: [{
                        label: '实际价格',
                        data: actualPrices,
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: false
                    }, {
                        label: '预测价格',
                        data: predictedPrices,
                        borderColor: '#764ba2',
                        backgroundColor: 'rgba(118, 75, 162, 0.1)',
                        borderWidth: 2,
                        borderDash: [5, 5],
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: 'LSTM股票价格预测结果'
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: '价格 ($)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: '时间'
                            }
                        }
                    }
                }
            });
        }

        // 思考题功能
        function selectOption(element, isCorrect) {
            const options = element.parentNode.querySelectorAll('.quiz-option');
            options.forEach(option => {
                option.classList.remove('selected', 'correct', 'incorrect');
            });
            
            element.classList.add('selected');
            
            setTimeout(() => {
                if (isCorrect) {
                    element.classList.add('correct');
                } else {
                    element.classList.add('incorrect');
                    // 显示正确答案
                    options.forEach(option => {
                        if (option.onclick.toString().includes('true')) {
                            option.classList.add('correct');
                        }
                    });
                }
                
                // 显示解析
                const resultDisplay = element.parentNode.parentNode.querySelector('.result-display');
                if (resultDisplay) {
                    resultDisplay.style.display = 'block';
                }
            }, 500);
        }

        function showLSTMAnswer() {
            document.getElementById('lstm-answer').style.display = 'block';
        }

        function showOpenAnswer() {
            document.getElementById('open-answer-ref').style.display = 'block';
        }

        // 页面加载完成后的初始化
        document.addEventListener('DOMContentLoaded', function() {
            // 代码高亮
            Prism.highlightAll();
            
            // 添加一些动画效果
            const sections = document.querySelectorAll('.section');
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.opacity = '1';
                        entry.target.style.transform = 'translateY(0)';
                    }
                });
            });
            
            sections.forEach(section => {
                section.style.opacity = '0';
                section.style.transform = 'translateY(20px)';
                section.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
                observer.observe(section);
            });
        });
    </script>
</body>
</html>